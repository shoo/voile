module voile.handler;

import core.thread;
import std.traits, std.range, std.exception, std.typetuple, std.concurrency, std.functional;

/* This template based from std.typecons.MemberFunctionGenerator */
private template MemberFunctionGeneratorEx(alias Policy)
{
private static:
	import std.string: format;
	import std.conv: to;
	//:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::://
	// Internal stuffs
	//:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::://

	enum CONSTRUCTOR_NAME = "__ctor";

	// true if functions are derived from a base class
	enum WITH_BASE_CLASS = __traits(hasMember, Policy, "BASE_CLASS_ID");

	// true if functions are specified as types, not symbols
	enum WITHOUT_SYMBOL = __traits(hasMember, Policy, "WITHOUT_SYMBOL");

	// preferred identifier for i-th parameter variable
	static if (__traits(hasMember, Policy, "PARAMETER_VARIABLE_ID"))
	{
		alias Policy.PARAMETER_VARIABLE_ID PARAMETER_VARIABLE_ID;
	}
	else
	{
		template PARAMETER_VARIABLE_ID(size_t i)
		{
			enum string PARAMETER_VARIABLE_ID = "a" ~ to!string(i);
				// default: a0, a1, ...
		}
	}

	// Returns a tuple consisting of 0,1,2,...,n-1.  For static foreach.
	template CountUp(size_t n)
	{
		static if (n > 0)
			alias TypeTuple!(CountUp!(n - 1), n - 1) CountUp;
		else
			alias TypeTuple!() CountUp;
	}


	//:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::://
	// Code generator
	//:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::://

	/*
	 * Runs through all the target overload sets and generates D code which
	 * implements all the functions in the overload sets.
	 */
	public string generateCode(overloads...)() @property
	{
		string code = "";

		// run through all the overload sets
		foreach (i_; CountUp!(0 + overloads.length)) // workaround
		{
			enum i = 0 + i_; // workaround
			alias overloads[i] oset;

			code ~= generateCodeForOverloadSet!(oset);

			static if (WITH_BASE_CLASS && oset.name != CONSTRUCTOR_NAME)
			{
				// The generated function declarations may hide existing ones
				// in the base class (cf. HiddenFuncError), so we put an alias
				// declaration here to reveal possible hidden functions.
				code ~= format("alias %s.%s %s;\n",
							Policy.BASE_CLASS_ID, // [BUG 2540] super.
							oset.name, oset.name );
			}
		}
		return code;
	}

	// handle each overload set
	private string generateCodeForOverloadSet(alias oset)() @property
	{
		string code = "";

		foreach (i_; CountUp!(0 + oset.contents.length)) // workaround
		{
			enum i = 0 + i_; // workaround
			code ~= generateFunction!(
					Policy.FUNCINFO_ID!(oset.name, i), oset.name,
					oset.contents[i]) ~ "\n";
		}
		return code;
	}

	/*
	 * Returns D code which implements the function func.  This function
	 * actually generates only the declarator part; the function body part is
	 * generated by the functionGenerator() policy.
	 */
	public string generateFunction(
			string myFuncInfo, alias exFuncInfo, string name, func...)() @property
	{
		enum isCtor = (name == CONSTRUCTOR_NAME);

		string code; // the result

		/*** Function Declarator ***/
		{
			alias exFuncInfo.FuncType Func;
			alias FunctionAttribute FA;
			enum atts     = exFuncInfo.attrib;
			enum realName = isCtor ? "this" : name;

			/* Made them CTFE funcs just for the sake of Format!(...) */

			// return type with optional "ref"
			static string make_returnType()
			{
				string rtype = "";

				if (!isCtor)
				{
					if (atts & FA.ref_)
						rtype ~= "ref ";
					rtype ~= myFuncInfo ~ ".RT";
				}
				return rtype;
			}
			enum returnType = make_returnType();

			// function attributes attached after declaration
			static string make_postAtts()
			{
				string poatts = "";
				if (atts & FA.pure_   ) poatts ~= " pure";
				if (atts & FA.nothrow_) poatts ~= " nothrow";
				if (atts & FA.property) poatts ~= " @property";
				if (atts & FA.safe    ) poatts ~= " @safe";
				if (atts & FA.trusted ) poatts ~= " @trusted";
				return poatts;
			}
			enum postAtts = make_postAtts();

			// function storage class
			static string make_storageClass()
			{
				string postc = "";
				if (is(Func ==    shared)) postc ~= " shared";
				if (is(Func ==     const)) postc ~= " const";
				if (is(Func == immutable)) postc ~= " immutable";
				return postc;
			}
			enum storageClass = make_storageClass();

			//
			if (exFuncInfo.abst)
				code ~= "override ";
			code ~= format("extern(%s) %s %s(%s) %s %s\n",
					exFuncInfo.linkage,
					returnType,
					realName,
					""~generateParameters!(myFuncInfo, exFuncInfo),
					postAtts, storageClass );
		}

		/*** Function Body ***/
		code ~= "{\n";
		{
			enum nparams = exFuncInfo.PT.length;

			/* Declare keywords: args, self and parent. */
			string preamble;

			preamble ~= "alias TypeTuple!(" ~ enumerateParameters!(nparams) ~ ") args;\n";
			if (!isCtor)
			{
				preamble ~= "alias " ~ name ~ " self;\n";
				if (WITH_BASE_CLASS && !exFuncInfo.abst)
					//preamble ~= "alias super." ~ name ~ " parent;\n"; // [BUG 2540]
					preamble ~= "auto parent = &super." ~ name ~ ";\n";
			}

			// Function body
			static if (WITHOUT_SYMBOL)
				enum fbody = Policy.generateFunctionBody!(name, func);
			else
				enum fbody = Policy.generateFunctionBody!(func);

			code ~= preamble;
			code ~= fbody;
		}
		code ~= "}";

		return code;
	}

	/*
	 * Returns D code which declares function parameters.
	 * "ref int a0, real a1, ..."
	 */
	private string generateParameters(string myFuncInfo, alias exFuncInfo)() @property
	{
		alias ParameterStorageClass STC;
		alias exFuncInfo.stcs stcs;
		alias exFuncInfo.valiadic valiadic;
		enum nparams = stcs.length;

		string params = ""; // the result

		foreach (i, stc; stcs)
		{
			if (i > 0)
				params ~= ", ";

			// Parameter storage classes.
			if (stc & STC.scope_) params ~= "scope ";
			if (stc & STC.out_  ) params ~= "out ";
			if (stc & STC.ref_  ) params ~= "ref ";
			if (stc & STC.lazy_ ) params ~= "lazy ";

			// Take parameter type from the FuncInfo.
			params ~= myFuncInfo ~ ".PT[" ~ to!string(i) ~ "]";

			// Declare a parameter variable.
			params ~= " " ~ PARAMETER_VARIABLE_ID!(i);
		}

		// Add some ellipsis part if needed.
		final switch (valiadic)
		{
			case Variadic.no:
				break;

			case Variadic.c, Variadic.d:
				// (...) or (a, b, ...)
				params ~= (nparams == 0) ? "..." : ", ...";
				break;

			case Variadic.typesafe:
				params ~= " ...";
				break;
		}

		return params;
	}

	// Returns D code which enumerates n parameter variables using comma as the
	// separator.  "a0, a1, a2, a3"
	private string enumerateParameters(size_t n)() @property
	{
		string params = "";

		foreach (i_; CountUp!(n))
		{
			enum i = 0 + i_; // workaround
			if (i > 0)
				params ~= ", ";
			params ~= PARAMETER_VARIABLE_ID!(i);
		}
		return params;
	}
}
/* This template based from std.functional.DelegateFaker */
private struct DelegateFakerEx(F) {
	template GeneratingPolicy()
	{
		enum WITHOUT_SYMBOL = true;
		template generateFunctionBody(unused...)
		{
			enum generateFunctionBody =
			q{
				auto fp = cast(F) &this;
				return fp(args, null);
			};
		}
	}
	template FuncInfo(Func)
	{
		alias         ReturnType!(Func)       RT;
		alias ParameterTypeTuple!(Func)[0..$-1] PT;
	}
	alias FuncInfo!(F) FuncInfo_doIt;
	template ExFuncInfo()
	{
		alias FunctionTypeOf!(F)                     FuncType;
		alias ReturnType!(F)                         RT;
		alias ParameterTypeTuple!(F)[0..$-1]         PT;
		alias ParameterStorageClassTuple!(F)[0..$-1] stcs;
		alias variadicFunctionStyle!(F)              valiadic;
		alias functionAttributes!(F)                 attrib;
		alias functionLinkage!(F)                    linkage;
		alias isAbstractFunction!(F)                 abst;
	}
	mixin( MemberFunctionGeneratorEx!(GeneratingPolicy!())
			.generateFunction!("FuncInfo_doIt", ExFuncInfo!(), "doIt") );
}

private auto toDelegateEx(Ptr, F)(Ptr ptr, F funcptr)
	if (Ptr.sizeof == size_t.sizeof && isCallable!F &&
	    is(Ptr: ParameterTypeTuple!F[$-1]))
{
	alias typeof(&(new DelegateFakerEx!(F)).doIt) DelType;
	static struct _ConnectData
	{
		union
		{
			struct
			{
				void* ptr;
				void* funcptr;
			}
			DelType dg;
		}
	}
	return _ConnectData(cast(void*)ptr, cast(void*)funcptr).dg;
}

unittest
{
	int[] testary;
	class Foo
	{
		int bar;
		void foo()
		{
			testary ~= bar;
		}
	}
	void delegate()[] dgs;
	static void func(Foo foo)
	{
		foo.foo();
	}
	foreach (i; 0..10)
	{
		auto f = new Foo;
		f.bar = i;
		dgs ~= toDelegateEx(f, &func);
	}
	foreach (dg; dgs)
	{
		dg();
	}
	assert(testary == [0,1,2,3,4,5,6,7,8,9]);
	
	
	testary =  null;
	
	extern(C) void delegate()[] dgs2;
	static extern(C) void func2(Foo foo)
	{
		foo.foo();
	}
	foreach (i; 0..10)
	{
		auto f = new Foo;
		f.bar = i;
		dgs2 ~= toDelegateEx(f, &func2);
	}
	foreach (dg; dgs2)
	{
		dg();
	}
	assert(testary == [0,1,2,3,4,5,6,7,8,9]);
}


/*******************************************************************************
 * List container
 */
private class List(T)
{
private:
	struct Node
	{
		T     val;
		Node* next;
		Node* prev;
		this(T v, Node* n, Node* p) pure nothrow
		{
			val = v;
			next = n;
			prev = p;
		}
	}
	Node* root;
public:
	/***************************************************************************
	 * 
	 */
	struct TIterator(TList)
	{
	private:
		alias typeof(*TList.root)    TNode;
		alias typeof(TList.root.val) E;
		TList  list;
		TNode* node;
		this(TList l, TNode* n) pure nothrow
		{
			list = l;
			node = n;
		}
	public:
		/***********************************************************************
		 * Iterator primitives.
		 */
		ref inout(E) opStar() inout
		{
			enforce(node !is list.root);
			return node.val;
		}
		
		/// ditto
		R opCast(R)() const nothrow pure
			if (is(R==bool))
		{
			return list !is null && node !is list.root;
		}
		
		/// ditto
		auto ref opUnary(string op)()
			if (op == "++")
		{
			enforce(node !is list.root);
			node = node.next;
			return this;
		}
		
		/// ditto
		auto ref opUnary(string op)()
			if (op == "--")
		{
			enforce(node.prev !is list.root);
			node = node.prev;
			return this;
		}
		
		/// ditto
		auto ref opOpAssign(string op)(size_t i)
			if (op == "+")
		{
			foreach (Unused; 0..i)
			{
				++this;
			}
			return this;
		}
		
		/// ditto
		auto ref opOpAssign(string op)(size_t i)
			if (op == "-")
		{
			foreach (Unused; 0..i)
			{
				--this;
			}
			return this;
		}
		
		/// ditto
		bool opEquals(TIterator itr) const pure nothrow
		{
			return itr.node is node;
		}
		
		/// ditto
		int opCmp(TIterator itr) const pure
		{
			enforce(list is itr.list);
			if (node is itr.node)
				return 0;
			const(TNode)* l = node;
			const(TNode)* r = itr.node;
			while (1)
			{
				l = l.next;
				r = r.next;
				if (l is itr.node)
					return 1;
				if (l is list.root)
					return 1;
				if (r is list.root)
					return -1;
				if (r is node)
					return -1;
			}
			assert(0);
		}
		
		
		/// ditto
		auto ref opBinary(string op)(TIterator itr)
			if (op == "-")
		{
			enforce(list is itr.list);
			size_t i;
			for (auto n = node; ; n = n.next)
			{
				if (n is itr.node)
					return i;
				n = n.next;
				enforce(n !is list.root);
				++i;
			}
			enforce(0);
		}
		
	}
	private static auto iterator(TList, TNode)(TList list, TNode* n) nothrow pure { return TIterator!TList(list, n); }
	alias TIterator!List Iterator;
	
	/***************************************************************************
	 * 
	 */
	struct TRange(TList)
	{
	private:
		alias typeof(*TList.root)     TNode;
		alias typeof(TList.root.val)  E;
		TList  _list;
		TNode* _first;
		TNode* _end;
		this(TList l, TNode* f, TNode* e) pure nothrow
		{
			_list  = l;
			_first = f;
			_end   = e;
		}
	public:
		/***********************************************************************
		 * Range primitives.
		 */
		bool empty() const @property
		{
			return _first is _end;
		}
		
		/// ditto
		inout(T) front() inout @property
		{
			enforce(!empty);
			return _first.val;
		}
		
		/***********************************************************************
		 * 
		 */
		inout(T) back() inout @property
		{
			enforce(!empty);
			return _end.prev.val;
		}
		
		/// ditto
		void popFront()
		{
			enforce(!empty);
			assert(_first is _first.next.prev);
			assert(_first is _first.prev.next);
			assert(_end is _end.next.prev);
			assert(_end is _end.prev.next);
			_first = _first.next;
		}
		
		/// ditto
		void popBack()
		{
			enforce(!empty);
			assert(_first is _first.next.prev);
			assert(_first is _first.prev.next);
			assert(_end is _end.next.prev);
			assert(_end is _end.prev.next);
			_end = _end.prev;
		}
		
		/// ditto
		auto save() @property
		{
			return this;
		}
		
		/***********************************************************************
		 * Iterator accessor
		 */
		auto ref begin() @property
		{
			return iterator(_list, _first);
		}
		
		/// ditto
		auto ref end() @property
		{
			return iterator(_list, _end);
		}
	}
	private static auto range(TList, TNode)(TList list, TNode* f, TNode* e) nothrow pure { return TRange!TList(list, f, e); }
	alias TRange!List Range;
	
	this() pure
	{
		static if (__traits(compiles, { T v; }))
		{
			T v;
		}
		else static if (__traits(compiles, { T v = T.init; }))
		{
			T v = T.init;
		}
		else
		{
			T v = void;
		}
		root = new Node(v, null, null);
		root.next = root;
		root.prev = root;
	}
	
	@property bool empty() const pure nothrow
	{
		return root.next is root;
	}
	
	@property T front() pure
	{
		enforce(root.next !is root);
		return root.next.val;
	}
	
	@property T back() pure
	{
		enforce(root.prev !is root);
		return root.prev.val;
	}
	
	
	/***************************************************************************
	 * Range accessor
	 */
	auto opSlice(this This)() pure nothrow
	{
		return range!This(this, root.next, root);
	}
	
	/***************************************************************************
	 * Iterator accessor
	 */
	auto begin(this This)() pure nothrow @property
	{
		return iterator!This(this, root.next);
	}
	
	/// ditto
	auto end(this This)() pure nothrow @property
	{
		return iterator!This(this, root);
	}
	
	/***************************************************************************
	 * Container premitive
	 */
	void stableInsertFront(T val) pure nothrow
	{
		auto node = new Node(val, root.next, root);
		root.next.prev = node;
		root.next = node;
	}
	/// ditto
	alias stableInsertFront insertFront;
	
	/// ditto
	void stableInsertBack(T val) pure nothrow
	{
		auto node = new Node(val, root, root.prev);
		root.prev.next = node;
		root.prev = node;
	}
	/// ditto
	alias stableInsertBack insertBack;
	/// ditto
	alias insertBack insert;
	
	
	/// ditto
	void stableInsertBefore(Iterator itr, T val)
	{
		enforce(this is itr.list);
		auto head = itr.node;
		auto node = new Node(val, head, head.prev);
		head.prev.next = node;
		head.prev = node;
	}
	
	/// ditto
	void stableInsertBefore(Range r, T val)
	{
		stableInsertBefore(r.begin, val);
	}
	
	/// ditto
	alias stableInsertBefore insertBefore;
	
	/// ditto
	void stableInsertAfter(Iterator itr, T val)
	{
		auto tail = itr.node;
		auto node = new Node(val, tail.next, tail);
		tail.next.prev = node;
		tail.next = node;
	}
	/// ditto
	void stableInsertAfter(Range r, T val)
	{
		stableInsertAfter(--r.end, val);
	}
	/// ditto
	alias stableInsertAfter insertAfter;
	
	/// ditto
	void stableLinearRemove(Range r)
	{
		auto n1 = r._first.prev;
		auto n2 = r._end;
		n1.next = n2;
		n2.prev = n1;
	}
	
	/// ditto
	void stableLinearRemove(Iterator itr)
	{
		auto n1 = itr.node.prev;
		auto n2 = itr.node.next;
		n1.next = n2;
		n2.prev = n1;
	}
	
	private static auto convert(Take!Range r)
	{
		auto first = r.source._first;
		auto end = first;
		foreach (i; 0..r.maxLength)
		{
			assert(end);
			assert(end.next);
			end = end.next;
		}
		return range(r.source._list, first, end);
	}
	
	/// ditto
	void stableLinearRemove(Take!Range r)
	{
		stableLinearRemove(convert(r));
	}
	
	/// ditto
	void clear() pure
	{
		root.next = root;
		root.prev = root;
	}
}


unittest
{
	auto list = new List!int;
	list.insertBack(1);
	assert(list.root.next.val == 1);
	assert(list.root.prev.val == 1);
	list.insertBack(2);
	assert(list.root.next.val == 1);
	assert(list.root.next.next.val == 2);
	assert(list.root.prev.val == 2);
	assert(list.root.prev.prev.val == 1);
	list.insertBack(3);
	assert(list.root.next.val == 1);
	assert(list.root.next.next.val == 2);
	assert(list.root.next.next.next.val == 3);
	assert(list.root.prev.val == 3);
	assert(list.root.prev.prev.val == 2);
	assert(list.root.prev.prev.prev.val == 1);
	list.insertFront(0);
	assert(list.root.next.val == 0);
	assert(list.root.prev.val == 3);
	list.insertAfter(list[], 4);
	list.insertBefore(list[], -1);
	auto r = list[];
	assert(r.begin < r.end);
	
	r.popFront();
	popFrontN(r, walkLength(r)-2);
	list.stableLinearRemove(take(r, 1));
	assert(walkLength(list[]) == 5);
	int[] ary;
	foreach (e; list[])
	{
		ary ~= e;
	}
	assert(ary == [-1,0,1,2,4]);
}

unittest
{
	auto list = new List!(const(int)*);
	int a = 30;
	list.insertBack(&a);
	list.insertAfter(list[], &a);
	list.insertBefore(list[], &a);
	
	foreach (p; list[])
	{
		assert(p is &a);
	}
}

unittest
{
	auto list = new List!(const(void delegate()));
	auto a = delegate void(){};
	list.insertBack(a);
	list.insertAfter(list[], a);
	list.insertBefore(list[], a);
	
	foreach (p; list[])
	{
		assert(p is a);
	}
}

unittest
{
	auto list = new List!int;
	list.insertBack(1);
	list.insertAfter(list[], 2);
	list.insertBefore(list[], 3);
	
	auto clist = cast(const)list;
	
	int i = 0;
	auto ary = [3,1,2];
	foreach (p; clist[])
	{
		assert(p == ary[i++]);
	}
}


/*******************************************************************************
 * Generic Handler
 * 
 * 
 * $(__123 a, bbb) = xxx
 * 
 * Macros:
 *     bbb  = cccccc
 *     _123 = [$1 ::: $($2)]
 */
struct Handler(F)
	if (isCallable!F && (is(ReturnType!(F) == void) || is(ReturnType!(F) : bool)))
{
private:
	template _ExFuncInfo(Func)
	{
		alias FunctionTypeOf!(Func)             FuncType;
		alias ReturnType!(Func)                 RT;
		alias ParameterTypeTuple!(Func)         PT;
		alias ParameterStorageClassTuple!(Func) stcs;
		alias variadicFunctionStyle!(Func)      valiadic;
		alias functionAttributes!(Func)         attrib;
		alias functionLinkage!(Func)            linkage;
		alias isAbstractFunction!(Func)         abst;
	}
	alias _ExFuncInfo!(F) _exFuncInfo;
	static private struct DummyData
	{
		alias _ExFuncInfo!(F) _exFuncInfo;
		template _EmitGeneratingPolicy()
		{
			template generateFunctionBody(unused...)
			{
				enum generateFunctionBody =
				q{
					static if (is(_exFuncInfo.RT: bool))
						return _exFuncInfo.RT.init;
				};
			}
		}
		mixin( MemberFunctionGeneratorEx!(_EmitGeneratingPolicy!())
				.generateFunction!("_exFuncInfo", _exFuncInfo, "emit")() );
	}
	template _EmitGeneratingPolicy()
	{
		template generateFunctionBody(unused...)
		{
			enum generateFunctionBody =
			q{
				static if (is(_exFuncInfo.RT: bool))
				{
					if (_procs is null)
						return _exFuncInfo.RT.init;
					_exFuncInfo.RT ret;
				}
				else
				{
					if (_procs is null)
						return;
				}
				static if (_exFuncInfo.attrib & FunctionAttribute.nothrow_)
				{
					try
					{
						foreach (proc; (*cast(ProcList*)&_procs)[].array())
						{
							static if (is(_exFuncInfo.RT: bool))
							{
								ret = proc(args);
								if (!ret)
									return ret;
							}
							else
							{
								proc(args);
							}
						}
					}
					catch (Throwable)
					{
					}
				}
				else
				{
					foreach (proc; (*cast(ProcList*)&_procs)[].array())
					{
						static if (is(_exFuncInfo.RT: bool))
						{
							ret = proc(args);
							if (!ret)
								return ret;
						}
						else
						{
							proc(args);
						}
					}
				}
				static if (is(_exFuncInfo.RT: bool))
					return ret;
			};
		}
	}
public:
	/***************************************************************************
	 * 
	 */
	version (D_Ddoc)
	{
		RetType emit(Args args);
		RetType emit(Args args) const;
		RetType emit(Args args) shared const;
	}
	else
	{
		mixin( MemberFunctionGeneratorEx!(_EmitGeneratingPolicy!())
		       .generateFunction!("_exFuncInfo", _exFuncInfo, "emit")() );
	}
	/// ditto
	alias emit opCall;
private:
	template isCastableDelegate(aFunc, bFunc)
	{
		alias ParameterStorageClass STC;
		template funcInfo(func)
		{
			alias ParameterStorageClassTuple!func stcs;
			alias ParameterTypeTuple!func         params;
			alias ReturnType!func                 ret;
			alias variadicFunctionStyle!func      valiadic;
			alias functionAttributes!func         attrib;
			alias functionLinkage!func            linkage;
		}
		template isStcsConvertible(Args...)
		{
			static if (Args.length > 1)
			{
				alias Args[0..Args.length/2] aStcs;
				alias Args[Args.length/2..$] bStcs;
				enum bool isStcsConvertible = aStcs[0] == bStcs[0]
				                           && isStcsConvertible!(aStcs[1..$], bStcs[1..$]);
			}
			else
			{
				enum bool isStcsConvertible = true;
			}
		}
		template isParamsConvertible(Args...)
		{
			static if (Args.length)
			{
				alias Args[0..Args.length/2] aParams;
				alias Args[Args.length/2..$] bParams;
				enum bool isParamsConvertible = (is(aParams[0] == bParams[0]) || isImplicitlyConvertible!(aParams[0], bParams[0]))
				                             && isParamsConvertible!(aParams[1..$], bParams[1..$]);
			}
			else
			{
				enum bool isParamsConvertible = true;
			}
		}
		
		alias funcInfo!aFunc aInfo;
		alias funcInfo!bFunc bInfo;
		// nothrow, pure, @safeは推論される可能性があるため、
		// 意図しない結果となるケースが有る。aFuncに属性が指定されていない限り無視する
		alias SetFunctionAttributes!(aInfo.ret delegate(), aInfo.linkage, aInfo.attrib) nonParamDgA;
		alias SetFunctionAttributes!(bInfo.ret delegate(), bInfo.linkage, bInfo.attrib & ((aInfo.attrib & FunctionAttribute.nothrow_) ? ~0: ~FunctionAttribute.nothrow_) & ((aInfo.attrib & FunctionAttribute.pure_) ? ~0: ~FunctionAttribute.pure_) & ((aInfo.attrib & (FunctionAttribute.safe | FunctionAttribute.trusted)) ? ~0: ~(FunctionAttribute.safe | FunctionAttribute.trusted))) nonParamDgB;
		import std.string;
		static if (aInfo.params.length == bInfo.params.length)
		{
			enum bool isCastableDelegate = aInfo.valiadic  == bInfo.valiadic
			                            && isCovariantWith!(FunctionTypeOf!nonParamDgA, FunctionTypeOf!nonParamDgB)
			                            && isStcsConvertible!(aInfo.stcs, bInfo.stcs)
			                            && isParamsConvertible!(aInfo.params, bInfo.params);
		}
		else
		{
			enum bool isCastableDelegate = false;
		}
	}
	unittest
	{
		class A{}
		class B: A{}
		class C: A{}
		static assert(isCastableDelegate!(void delegate(int), void delegate(int)));
		static assert(isCastableDelegate!(void delegate(int, int), void delegate(int, int)));
		static assert(isCastableDelegate!(void delegate(A, int), void delegate(A, int)));
		static assert(isCastableDelegate!(void delegate(B, int), void delegate(A, int)));
		static assert(isCastableDelegate!(void delegate(B, A), void delegate(A, A)));
		static assert(isCastableDelegate!(void delegate(int), void delegate(uint)));
		static assert(isCastableDelegate!(void delegate(byte), void delegate(int)));
		static assert(isCastableDelegate!(void delegate(byte) nothrow, void delegate(int) nothrow));
		static assert(isCastableDelegate!(void delegate(byte) @safe, void delegate(int) @system));
		static assert(isCastableDelegate!(void delegate(byte) @trusted, void delegate(int) @safe));
		static assert(isCastableDelegate!(void delegate(byte) @safe, void delegate(int) @trusted));
		//static assert(!isCastableDelegate!(void delegate(byte) @system, void delegate(int) @safe));
		static assert(!isCastableDelegate!(void delegate(B, A), void delegate(A, B)));
		static assert(!isCastableDelegate!(void delegate(C, C), void delegate(A, B)));
	}
	alias typeof(&DummyData.init.emit) Proc;
	alias _exFuncInfo.PT Args;
	alias _exFuncInfo.RT RetType;
	alias List!Proc ProcList;
	ProcList _procs;
	
public:
	/***************************************************************************
	 * 
	 */
	alias ProcList.Iterator HandlerProcId;
	
	/***************************************************************************
	 * Connect
	 * 
	 * Params:
	 *     fn = delegate, function, Tid, Object( has opCall ), Fiber
	 */
	HandlerProcId connect(Func)(Func fn)
		if (is(typeof( toDelegate(fn) ))
		 && isCastableDelegate!(Proc, Func))
	{
		if (_procs is null)
			_procs = new ProcList;
		_procs.stableInsertBack( cast(Proc)toDelegate(fn) );
		return _procs.begin;
	}
	
	/// ditto
	void opOpAssign(string op, Func)(Func dg) if (op == "~" && is(typeof(connect(dg))))
	{
		connect(dg);
	}	
	
	
	/// ditto
	alias put = connect;
	
	
	/***************************************************************************
	 * 
	 */
	HandlerProcId connectedId(Func)(Func fn)
		if (is(typeof( toDelegate(fn) ))
		 && isCastableDelegate!(Func, Proc))
	{
		if (_procs is null)
			return HandlerProcId.init;
		auto f = cast(Proc)toDelegate(fn);
		for (auto r = _procs[]; !r.empty; r.popBack())
		{
			if (r.back == f)
			{
				return --r.end;
			}
		}
		
		return HandlerProcId.init;
	}
	
	
	static if (Args.length > 0 && !hasUnsharedAliasing!Args)
	{
		static assert(Tid.sizeof == (void*).sizeof);
		private static void _TidCaller(Args args, Tid* tid)
		{
			(*cast(Tid*)&tid).send(args);
		}
		HandlerProcId connect(Func)(Func tid)
			if (is(Func == Tid))
		{
			return connect(toDelegateEx(*cast(Tid**)&tid, &_TidCaller));
		}
		
		HandlerProcId connectedId(Func)(Func tid)
			if (is(Func == Tid))
		{
			return connected(toDelegateEx(*cast(Tid**)&tid, &_TidCaller));
		}
	}
	
	
	static if (Args.length == 0)
	{
		private static void _FiberCaller(Fiber fb)
		{
			fb.call();
		}
		HandlerProcId connect(Func)(Func fib)
			if (is(Func: Fiber))
		{
			return connect(toDelegateEx(fib, &_FiberCaller));
		}
		HandlerProcId connectedId(Func)(Func fib)
			if (is(Func: Fiber))
		{
			return connectedId(toDelegateEx(fib, &_FiberCaller));
		}
	}
	
	
	/***************************************************************************
	 * Concut
	 * 
	 * Params:
	 *     procs = other Handler
	 */
	void opOpAssign(string op, ProcContainer)(auto ref ProcContainer procs)
		if (op == "~" && is(ForeachType!(typeof(ProcContainer.init[])): Proc))
	{
		if (_procs is null)
			_procs = new ProcList;
		foreach (p; procs[])
		{
			_procs.stableInsertBack(p);
		}
	}
	
	
	
	/***************************************************************************
	 * 
	 */
	auto opSlice()
	{
		if (_procs is null)
			_procs = new ProcList;
		return _procs[];
	}
	
	
	/***************************************************************************
	 * 
	 */
	bool opCast(T)() pure nothrow const
		if (is(T == bool))
	{
		return !(_procs is null) && !_procs.empty();
	}
	
	
	/***************************************************************************
	 * 
	 */
	void disconnect(Func)(Func fn)
		if (is(typeof( connectedId(fn) )))
	{
		disconnect(connectedId(fn));
	}
	
	/// ditto
	void disconnect(Func)(Func id)
		if (is(Func == HandlerProcId))
	{
		enforce(id);
		enforce(!(_procs is null));
		_procs.stableLinearRemove(id);
	}
	
	/// ditto
	void disconnect(Func)(Func hnd)
		if (is(Func == Handler))
	{
		foreach (p; hnd._procs[])
		{
			_procs.stableLinearRemove(p);
		}
	}
	
	/// ditto
	alias remove = disconnect;
	
	/***************************************************************************
	 * 
	 */
	void clear() pure
	{
		if (_procs is null)
			return;
		_procs.clear();
	}
}


unittest
{
	static string teststr;
	import std.conv: to;
	static void foo(int i)
	{
		teststr ~= "foo" ~ to!string(i);
	}
	Handler!(typeof(foo)) h;
	auto id1 = h.connect( &foo );
	h.connect( (int i){teststr ~= "dg" ~ to!string(i);} );
	auto id2 = h.connect( new class
	{
		void opCall(int i)
		{
			teststr ~= "opCall" ~ to!string(i);
		}
	} );
	teststr = "";
	h(1);
	assert(teststr == "foo1dg1opCall1", teststr);
	h.disconnect( &foo );
	teststr = "";
	h(2);
	assert(teststr == "dg2opCall2", teststr);
	assert(!h.connectedId( &foo ));
	
	h.disconnect(id2);
	h.connect(thisTid);
	h.clear();
	
	
	void bar()
	{
		while (1)
		{
			teststr ~= "bar";
			Fiber.yield();
		}
	}
	void bar2()
	{
		teststr ~= "bar2";
	}
	Handler!(typeof(bar)) h2;
	Fiber fib = new Fiber(&bar);
	h2.connect(fib);
	teststr = "";
	h2();
	assert(teststr == "bar");
	h2();
	assert(teststr == "barbar");
	
	Handler!(typeof(bar)) h3;
	h3.connect(&bar2);
	static assert(__traits(compiles, h2 ~= h3));
	h2 ~= h3;
	teststr = "";
	h2();
	assert(teststr == "barbar2");
}

unittest
{
	Handler!(void delegate() const) hndConst;
	Handler!(void delegate() immutable) hndImmutable;
	Handler!(void delegate() shared) hndShared;
	Handler!(void delegate() shared const) hndSharedConst;
	/* test for qualifier */
	{
		struct SQual
		{
			void fnConst() const {}
			void fnImmutable() immutable {}
			void fnShared() shared {}
			void fnSharedConst() shared const {}
		}
		SQual sq;
		auto dgConst       = toDelegate(&sq.fnConst);
		auto dgImmutable   = toDelegate(&sq.fnImmutable);
		auto dgShared      = toDelegate(&sq.fnShared);
		auto dgSharedConst = toDelegate(&sq.fnSharedConst);
		static assert(is(FunctionTypeOf!dgConst       == const));
		static assert(is(FunctionTypeOf!dgImmutable   == immutable));
		static assert(is(FunctionTypeOf!dgShared      == shared));
		static assert(is(FunctionTypeOf!dgSharedConst == shared));
		static assert(is(FunctionTypeOf!dgSharedConst == const));
		hndConst.connect(&sq.fnConst);
		hndConst.disconnect(&sq.fnConst);
		hndImmutable.connect(&sq.fnImmutable);
		hndImmutable.disconnect(&sq.fnImmutable);
		hndShared.connect(&sq.fnShared);
		hndShared.disconnect(&sq.fnShared);
		hndSharedConst.connect(&sq.fnSharedConst);
		hndSharedConst.disconnect(&sq.fnSharedConst);
	}
	{
		struct SConst       { void opCall() const {} }
		struct SImmutable   { void opCall() immutable {} }
		struct SShared      { void opCall() shared {} }
		struct SSharedConst { void opCall() shared const {} }
		auto idConst = hndConst.connect(SConst.init);
		hndConst.disconnect(idConst);
		auto idImmutable = hndImmutable.connect(SImmutable.init);
		hndImmutable.disconnect(idImmutable);
		auto idShared = hndShared.connect(SShared.init);
		hndShared.disconnect(idShared);
		auto idSharedConst = hndSharedConst.connect(SSharedConst.init);
		hndSharedConst.disconnect(idSharedConst);
	}

}
