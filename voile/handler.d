/*******************************************************************************
 * Common Handler type
 */
module voile.handler;

import core.thread;
import std.traits, std.range, std.exception, std.typetuple, std.concurrency, std.functional;

private template isVirtualMethod(func...)
	if (func.length == 1)
{
	enum isVirtualMethod = __traits(isVirtualMethod, func[0]);
}

/* This template based from std.typecons.MemberFunctionGenerator */
private template MemberFunctionGeneratorEx(alias Policy)
{
private static:
	//:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::://
	// Internal stuffs
	//:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::://
	import std.format;

	enum CONSTRUCTOR_NAME = "__ctor";

	// true if functions are derived from a base class
	enum WITH_BASE_CLASS = __traits(hasMember, Policy, "BASE_CLASS_ID");

	// true if functions are specified as types, not symbols
	enum WITHOUT_SYMBOL = __traits(hasMember, Policy, "WITHOUT_SYMBOL");

	// preferred identifier for i-th parameter variable
	static if (__traits(hasMember, Policy, "PARAMETER_VARIABLE_ID"))
	{
		alias PARAMETER_VARIABLE_ID = Policy.PARAMETER_VARIABLE_ID;
	}
	else
	{
		enum string PARAMETER_VARIABLE_ID(size_t i) = format("a%s", i);
			// default: a0, a1, ...
	}

	// Returns a tuple consisting of 0,1,2,...,n-1.  For static foreach.
	template CountUp(size_t n)
	{
		static if (n > 0)
			alias CountUp = AliasSeq!(CountUp!(n - 1), n - 1);
		else
			alias CountUp = AliasSeq!();
	}


	//:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::://
	// Code generator
	//:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::://

	/*
	 * Runs through all the target overload sets and generates D code which
	 * implements all the functions in the overload sets.
	 */
	public string generateCode(overloads...)() @property // @suppress(dscanner.confusing.function_attributes)
	{
		string code = "";

		// run through all the overload sets
		foreach (i_; CountUp!(0 + overloads.length)) // workaround
		{
			enum i = 0 + i_; // workaround
			alias oset = overloads[i];

			code ~= generateCodeForOverloadSet!(oset);

			static if (WITH_BASE_CLASS && oset.name != CONSTRUCTOR_NAME)
			{
				// The generated function declarations may hide existing ones
				// in the base class (cf. HiddenFuncError), so we put an alias
				// declaration here to reveal possible hidden functions.
				code ~= format("alias %s = %s.%s;\n",
				            oset.name,
				            Policy.BASE_CLASS_ID, // [BUG 2540] super.
				            oset.name);
			}
		}
		return code;
	}

	// handle each overload set
	private string generateCodeForOverloadSet(alias oset)() @property // @suppress(dscanner.confusing.function_attributes)
	{
		string code = "";

		template ExFuncInfo(alias func)
		{
			alias FuncType     = FunctionTypeOf!func;
			alias RT           = ReturnType!func;
			alias PT           = ParameterTypeTuple!func[0..$];
			alias stcs         = ParameterStorageClassTuple!func[0..$];
			alias valiadic     = variadicFunctionStyle!func;
			alias attrib       = functionAttributes!func;
			alias linkage      = functionLinkage!func;
			alias abst         = isAbstractFunction!func;
			alias virt         = isVirtualMethod!func;
		}
		foreach (i_; CountUp!(0 + oset.contents.length)) // workaround
		{
			enum i = 0 + i_; // workaround
			code ~= generateFunction!(
			        Policy.FUNCINFO_ID!(oset.name, i),
			        ExFuncInfo!(oset.contents[i]),
			        oset.name,
			        oset.contents[i]) ~ "\n";
		}
		return code;
	}

	/*
	 * Returns D code which implements the function func.  This function
	 * actually generates only the declarator part; the function body part is
	 * generated by the functionGenerator() policy.
	 */
	public string generateFunction( // @suppress(dscanner.confusing.function_attributes)
	        string myFuncInfo, alias exFuncInfo, string name, func... )() @property
	{
		import std.format : format;
		
		enum isCtor = (name == CONSTRUCTOR_NAME);
		
		string code; // the result
		
		auto paramsRes = generateParameters!(myFuncInfo, exFuncInfo, func)();
		code ~= paramsRes.imports;
		
		/*** Function Declarator ***/
		{
			alias Func    = exFuncInfo.FuncType;
			alias FA      = FunctionAttribute;
			enum atts     = exFuncInfo.attrib;
			enum realName = isCtor ? "this" : name;
			
			// FIXME?? Make it so that these aren't CTFE funcs any more, since
			// Format is deprecated, and format works at compile time?
			/* Made them CTFE funcs just for the sake of Format!(...) */
			
			// return type with optional "ref"
			static string make_returnType()
			{
				string rtype = "";
				
				if (!isCtor)
				{
					if (atts & FA.ref_) rtype ~= "ref ";
					rtype ~= myFuncInfo ~ ".RT";
				}
				return rtype;
			}
			enum returnType = make_returnType();
			
			// function attributes attached after declaration
			static string make_postAtts()
			{
				string poatts = "";
				if (atts & FA.pure_   ) poatts ~= " pure";
				if (atts & FA.nothrow_) poatts ~= " nothrow";
				if (atts & FA.property) poatts ~= " @property";
				if (atts & FA.safe    ) poatts ~= " @safe";
				if (atts & FA.trusted ) poatts ~= " @trusted";
				if (atts & FA.nogc    ) poatts ~= " @nogc";
				return poatts;
			}
			enum postAtts = make_postAtts();
			
			// function storage class
			static string make_storageClass()
			{
				string postc = "";
				if (is(Func ==    shared)) postc ~= " shared";
				if (is(Func ==     const)) postc ~= " const";
				if (is(Func ==     inout)) postc ~= " inout";
				if (is(Func == immutable)) postc ~= " immutable";
				return postc;
			}
			enum storageClass = make_storageClass();
			
			//
			static if (func.length && __traits(isVirtualMethod, func))
			    code ~= "override ";
			code ~= format("extern(%s) %s %s(%s) %s %s\n",
			        exFuncInfo.linkage,
			        returnType,
			        realName,
			        paramsRes.params,
			        postAtts, storageClass );
		}

		/*** Function Body ***/
		code ~= "{\n";
		{
			enum nparams = exFuncInfo.PT.length;
			
			/* Declare keywords: args, self and parent. */
			string preamble;
			
			preamble ~= "alias args = AliasSeq!(" ~ enumerateParameters!(nparams) ~ ");\n";
			if (!isCtor)
			{
				preamble ~= "alias self = " ~ name ~ ";\n";
				if (WITH_BASE_CLASS && !exFuncInfo.abst)
				    preamble ~= "alias parent = AliasSeq!(__traits(getMember, super, \"" ~ name ~ "\"))[0];";
			}
			
			// Function body
			static if (WITHOUT_SYMBOL)
				enum fbody = Policy.generateFunctionBody!(name, func);
			else
				enum fbody = Policy.generateFunctionBody!(func);
			
			code ~= preamble;
			code ~= fbody;
		}
		code ~= "}";
		
		return code;
	}
	
	/*
	 * Returns D code which declares function parameters,
	 * and optionally any imports (e.g. core.vararg)
	 * "ref int a0, real a1, ..."
	 */
	static struct GenParams { string imports, params; }
	private GenParams generateParameters(string myFuncInfo, alias exFuncInfo, func...)()
	{
		alias STC = ParameterStorageClass;
		alias stcs = exFuncInfo.stcs;
		enum nparams = stcs.length;
		
		string imports = ""; // any imports required
		string params = ""; // parameters
		
		foreach (i, stc; stcs)
		{
			if (i > 0) params ~= ", ";
			
			// Parameter storage classes.
			if (stc & STC.scope_) params ~= "scope ";
			if (stc & STC.out_  ) params ~= "out ";
			if (stc & STC.ref_  ) params ~= "ref ";
			if (stc & STC.lazy_ ) params ~= "lazy ";
			
			// Take parameter type from the FuncInfo.
			params ~= format("%s.PT[%s]", myFuncInfo, i);
			
			// Declare a parameter variable.
			params ~= " " ~ PARAMETER_VARIABLE_ID!(i);
		}

		// Add some ellipsis part if needed.
		final switch (exFuncInfo.valiadic)
		{
		case Variadic.no:
			break;
		
		case Variadic.c, Variadic.d:
			imports ~= "import core.vararg;\n";
			// (...) or (a, b, ...)
			params ~= (nparams == 0) ? "..." : ", ...";
			break;
		
		case Variadic.typesafe:
			params ~= " ...";
			break;
		}
		
		return typeof(return)(imports, params);
	}

	// Returns D code which enumerates n parameter variables using comma as the
	// separator.  "a0, a1, a2, a3"
	private string enumerateParameters(size_t n)() @property // @suppress(dscanner.confusing.function_attributes)
	{
		string params = "";
		
		foreach (i_; CountUp!(n))
		{
			enum i = 0 + i_; // workaround
			if (i > 0) params ~= ", ";
			params ~= PARAMETER_VARIABLE_ID!(i);
		}
		return params;
	}
}


/* This template based from std.functional.DelegateFaker */
private struct DelegateFakerEx(F) {
	template GeneratingPolicy()
	{
		enum WITHOUT_SYMBOL = true;
		template generateFunctionBody(unused...)
		{
			enum generateFunctionBody =
			q{
				auto fp = cast(F) &this;
				return fp(args, null);
			};
		}
	}
	template FuncInfo(Func)
	{
		alias RT = ReturnType!(Func);
		alias PT = ParameterTypeTuple!(Func)[0..$-1];
	}
	alias FuncInfo_doIt = FuncInfo!(F);
	template ExFuncInfo()
	{
		alias FuncType = FunctionTypeOf!F;
		alias RT       = ReturnType!F;
		alias PT       = ParameterTypeTuple!F[0..$-1];
		alias stcs     = ParameterStorageClassTuple!F[0..$-1];
		alias valiadic = variadicFunctionStyle!F;
		alias attrib   = functionAttributes!F;
		alias linkage  = functionLinkage!F;
		alias abst     = isAbstractFunction!F;
		alias virt     = isVirtualMethod!F;
	}
	mixin( MemberFunctionGeneratorEx!(GeneratingPolicy!())
			.generateFunction!("FuncInfo_doIt", ExFuncInfo!(), "doIt") );
}

private auto toDelegateEx(Ptr, F)(Ptr ptr, F funcptr)
	if (Ptr.sizeof == size_t.sizeof && isCallable!F &&
	    is(Ptr: ParameterTypeTuple!F[$-1]))
{
	alias DelType = typeof(&(new DelegateFakerEx!(F)).doIt);
	static struct _ConnectData
	{
		union
		{
			struct
			{
				void* ptr;
				void* funcptr;
			}
			DelType dg;
		}
	}
	return _ConnectData(cast(void*)ptr, cast(void*)funcptr).dg;
}

@system unittest
{
	int[] testary;
	class Foo
	{
		int bar;
		void foo()
		{
			testary ~= bar;
		}
	}
	void delegate()[] dgs;
	static void func(Foo foo)
	{
		foo.foo();
	}
	foreach (i; 0..10)
	{
		auto f = new Foo;
		f.bar = i;
		dgs ~= toDelegateEx(f, &func);
	}
	foreach (dg; dgs)
	{
		dg();
	}
	assert(testary == [0,1,2,3,4,5,6,7,8,9]);
	
	
	testary =  null;
	
	extern(C) void delegate()[] dgs2;
	static extern(C) void func2(Foo foo)
	{
		foo.foo();
	}
	foreach (i; 0..10)
	{
		auto f = new Foo;
		f.bar = i;
		dgs2 ~= toDelegateEx(f, &func2);
	}
	foreach (dg; dgs2)
	{
		dg();
	}
	assert(testary == [0,1,2,3,4,5,6,7,8,9]);
}


/*******************************************************************************
 * List container
 */
private class List(T)
{
private:
	static struct Node
	{
		T     val;
		Node* next;
		Node* prev;
		this(T v, Node* n, Node* p) pure nothrow
		{
			val = v;
			next = n;
			prev = p;
		}
	}
	Node* root;
public:
	/***************************************************************************
	 * 
	 */
	static struct TIterator(TList) // @suppress(dscanner.suspicious.incomplete_operator_overloading)
	{
	private:
		alias TNode = typeof(*TList.root);
		alias E     = typeof(TList.root.val);
		TList  list;
		TNode* node;
		this(TList l, TNode* n) pure nothrow
		{
			list = l;
			node = n;
		}
	public:
		/***********************************************************************
		 * Iterator primitives.
		 */
		ref inout(E) opStar() inout
		{
			enforce(node !is list.root);
			return node.val;
		}
		
		/// ditto
		R opCast(R)() const nothrow pure
			if (is(R==bool))
		{
			return list !is null && node !is list.root;
		}
		
		/// ditto
		auto ref opUnary(string op)()
			if (op == "++")
		{
			enforce(node !is list.root);
			node = node.next;
			return this;
		}
		
		/// ditto
		auto ref opUnary(string op)()
			if (op == "--")
		{
			enforce(node.prev !is list.root);
			node = node.prev;
			return this;
		}
		
		/// ditto
		auto ref opOpAssign(string op)(size_t i)
			if (op == "+")
		{
			foreach (Unused; 0..i)
			{
				++this;
			}
			return this;
		}
		
		/// ditto
		auto ref opOpAssign(string op)(size_t i)
			if (op == "-")
		{
			foreach (Unused; 0..i)
			{
				--this;
			}
			return this;
		}
		
		/// ditto
		bool opEquals(TIterator itr) const pure nothrow
		{
			return itr.node is node;
		}
		
		/// ditto
		int opCmp(TIterator itr) const pure
		{
			enforce(list is itr.list);
			if (node is itr.node)
				return 0;
			const(TNode)* l = node;
			const(TNode)* r = itr.node;
			while (1)
			{
				l = l.next;
				r = r.next;
				if (l is itr.node)
					return 1;
				if (l is list.root)
					return 1;
				if (r is list.root)
					return -1;
				if (r is node)
					return -1;
			}
			assert(0);
		}
		
		
		/// ditto
		auto ref opBinary(string op)(TIterator itr)
			if (op == "-")
		{
			enforce(list is itr.list);
			size_t i;
			for (auto n = node; ; n = n.next)
			{
				if (n is itr.node)
					return i;
				n = n.next;
				enforce(n !is list.root);
				++i;
			}
			enforce(0);
		}
		
	}
	private static auto iterator(TList, TNode)(TList list, TNode* n) nothrow pure { return TIterator!TList(list, n); }
	alias Iterator = TIterator!List;
	
	/***************************************************************************
	 * 
	 */
	static struct TRange(TList)
	{
	private:
		alias TNode = typeof(*TList.root);
		alias E     = typeof(TList.root.val);
		TList  _list;
		TNode* _first;
		TNode* _end;
		this(TList l, TNode* f, TNode* e) pure nothrow
		{
			_list  = l;
			_first = f;
			_end   = e;
		}
	public:
		/***********************************************************************
		 * Range primitives.
		 */
		bool empty() const @property
		{
			return _first is _end;
		}
		
		/// ditto
		inout(T) front() inout @property
		{
			enforce(!empty);
			return _first.val;
		}
		
		/***********************************************************************
		 * 
		 */
		inout(T) back() inout @property
		{
			enforce(!empty);
			return _end.prev.val;
		}
		
		/// ditto
		void popFront()
		{
			enforce(!empty);
			assert(_first is _first.next.prev);
			assert(_first is _first.prev.next);
			assert(_end is _end.next.prev);
			assert(_end is _end.prev.next);
			_first = _first.next;
		}
		
		/// ditto
		void popBack()
		{
			enforce(!empty);
			assert(_first is _first.next.prev);
			assert(_first is _first.prev.next);
			assert(_end is _end.next.prev);
			assert(_end is _end.prev.next);
			_end = _end.prev;
		}
		
		/// ditto
		auto save()
		{
			return this;
		}
		
		/***********************************************************************
		 * Iterator accessor
		 */
		auto ref begin() @property // @suppress(dscanner.confusing.function_attributes)
		{
			return iterator(_list, _first);
		}
		
		/// ditto
		auto ref end() @property // @suppress(dscanner.confusing.function_attributes)
		{
			return iterator(_list, _end);
		}
	}
	private static auto range(TList, TNode)(TList list, TNode* f, TNode* e) nothrow pure
	{
		return TRange!TList(list, f, e);
	}
	alias Range = TRange!List;
	
	this() pure
	{
		static if (__traits(compiles, { T tmpVal; }))
		{
			T v;
		}
		else static if (__traits(compiles, { T tmpVal = T.init; }))
		{
			T v = T.init;
		}
		else
		{
			T v = void;
		}
		root = new Node(v, null, null);
		root.next = root;
		root.prev = root;
	}
	
	@property bool empty() const pure nothrow
	{
		return root.next is root;
	}
	
	@property T front() pure
	{
		enforce(root.next !is root);
		return root.next.val;
	}
	
	@property T back() pure
	{
		enforce(root.prev !is root);
		return root.prev.val;
	}
	
	
	/***************************************************************************
	 * Range accessor
	 */
	auto opSlice(this This)() pure nothrow
	{
		return range!This(this, root.next, root);
	}
	
	/***************************************************************************
	 * Iterator accessor
	 */
	auto begin(this This)() pure nothrow @property // @suppress(dscanner.confusing.function_attributes)
	{
		return iterator!This(this, root.next);
	}
	
	/// ditto
	auto end(this This)() pure nothrow @property // @suppress(dscanner.confusing.function_attributes)
	{
		return iterator!This(this, root);
	}
	
	/***************************************************************************
	 * Container premitive
	 */
	void stableInsertFront(T val) pure nothrow
	{
		auto node = new Node(val, root.next, root);
		root.next.prev = node;
		root.next = node;
	}
	/// ditto
	alias insertFront = stableInsertFront;
	
	/// ditto
	void stableInsertBack(T val) pure nothrow
	{
		auto node = new Node(val, root, root.prev);
		root.prev.next = node;
		root.prev = node;
	}
	/// ditto
	alias insertBack = stableInsertBack;
	/// ditto
	alias insert = insertBack;
	
	
	/// ditto
	void stableInsertBefore(Iterator itr, T val)
	{
		enforce(this is itr.list);
		auto head = itr.node;
		auto node = new Node(val, head, head.prev);
		head.prev.next = node;
		head.prev = node;
	}
	
	/// ditto
	void stableInsertBefore(Range r, T val)
	{
		stableInsertBefore(r.begin, val);
	}
	
	/// ditto
	alias insertBefore = stableInsertBefore;
	
	/// ditto
	void stableInsertAfter(Iterator itr, T val)
	{
		auto tail = itr.node;
		auto node = new Node(val, tail.next, tail);
		tail.next.prev = node;
		tail.next = node;
	}
	/// ditto
	void stableInsertAfter(Range r, T val)
	{
		stableInsertAfter(--r.end, val);
	}
	/// ditto
	alias insertAfter = stableInsertAfter;
	
	/// ditto
	void stableLinearRemove(Range r)
	{
		auto n1 = r._first.prev;
		auto n2 = r._end;
		n1.next = n2;
		n2.prev = n1;
	}
	
	/// ditto
	void stableLinearRemove(Iterator itr)
	{
		auto n1 = itr.node.prev;
		auto n2 = itr.node.next;
		n1.next = n2;
		n2.prev = n1;
	}
	
	private static auto convert(Take!Range r)
	{
		auto first = r.source._first;
		auto end = first;
		foreach (i; 0..r.maxLength)
		{
			assert(end);
			assert(end.next);
			end = end.next;
		}
		return range(r.source._list, first, end);
	}
	
	/// ditto
	void stableLinearRemove(Take!Range r)
	{
		stableLinearRemove(convert(r));
	}
	
	/// ditto
	void clear() pure
	{
		root.next = root;
		root.prev = root;
	}
}


@system unittest
{
	auto list = new List!int;
	list.insertBack(1);
	assert(list.root.next.val == 1);
	assert(list.root.prev.val == 1);
	list.insertBack(2);
	assert(list.root.next.val == 1);
	assert(list.root.next.next.val == 2);
	assert(list.root.prev.val == 2);
	assert(list.root.prev.prev.val == 1);
	list.insertBack(3);
	assert(list.root.next.val == 1);
	assert(list.root.next.next.val == 2);
	assert(list.root.next.next.next.val == 3);
	assert(list.root.prev.val == 3);
	assert(list.root.prev.prev.val == 2);
	assert(list.root.prev.prev.prev.val == 1);
	list.insertFront(0);
	assert(list.root.next.val == 0);
	assert(list.root.prev.val == 3);
	list.insertAfter(list[], 4);
	list.insertBefore(list[], -1);
	auto r = list[];
	assert(r.begin < r.end);
	
	r.popFront();
	popFrontN(r, walkLength(r)-2);
	list.stableLinearRemove(take(r, 1));
	assert(walkLength(list[]) == 5);
	int[] ary;
	foreach (e; list[])
	{
		ary ~= e;
	}
	assert(ary == [-1,0,1,2,4]);
}

@system unittest
{
	auto list = new List!(const(int)*);
	int a = 30;
	list.insertBack(&a);
	list.insertAfter(list[], &a);
	list.insertBefore(list[], &a);
	
	foreach (p; list[])
	{
		assert(p is &a);
	}
}

@system unittest
{
	auto list = new List!(const(void delegate()));
	auto a = delegate void(){};
	list.insertBack(a);
	list.insertAfter(list[], a);
	list.insertBefore(list[], a);
	
	foreach (p; list[])
	{
		assert(p is a);
	}
}

@system unittest
{
	auto list = new List!int;
	list.insertBack(1);
	list.insertAfter(list[], 2);
	list.insertBefore(list[], 3);
	
	auto clist = cast(const)list;
	
	int i;
	auto ary = [3,1,2];
	foreach (p; clist[])
	{
		assert(p == ary[i++]);
	}
}

///
template isCastableDelegate(aFunc, bFunc)
{
	alias STC = ParameterStorageClass;
	template funcInfo(func)
	{
		alias stcs     = ParameterStorageClassTuple!func;
		alias params   = ParameterTypeTuple!func;
		alias ret      = ReturnType!func;
		alias valiadic = variadicFunctionStyle!func;
		alias attrib   = functionAttributes!func;
		alias linkage  = functionLinkage!func;
	}
	template isStcsConvertible(Args...)
	{
		static if (Args.length > 1)
		{
			alias aStcs = Args[0..Args.length/2];
			alias bStcs = Args[Args.length/2..$];
			enum bool isStcsConvertible = aStcs[0] == bStcs[0]
			                           && isStcsConvertible!(aStcs[1..$], bStcs[1..$]);
		}
		else
		{
			enum bool isStcsConvertible = true;
		}
	}
	template isParamsConvertible(Args...)
	{
		static if (Args.length)
		{
			alias aParams = Args[0..Args.length/2];
			alias bParams = Args[Args.length/2..$];
			enum bool isParamsConvertible = (is(aParams[0] == bParams[0]) || isImplicitlyConvertible!(aParams[0], bParams[0]))
			                             && isParamsConvertible!(aParams[1..$], bParams[1..$]);
		}
		else
		{
			enum bool isParamsConvertible = true;
		}
	}
	
	alias aInfo = funcInfo!aFunc;
	alias bInfo = funcInfo!bFunc;
	// nothrow, pure, @safe, @nogcは推論される可能性があるため、
	// 意図しない結果となるケースが有る。aFuncに属性が指定されていない限り無視する
	alias nonParamDgA = SetFunctionAttributes!(aInfo.ret delegate(), aInfo.linkage, aInfo.attrib);
	alias nonParamDgB = SetFunctionAttributes!(bInfo.ret delegate(), bInfo.linkage, bInfo.attrib &
	    ((aInfo.attrib & FunctionAttribute.nothrow_) ? ~0: ~FunctionAttribute.nothrow_) &
	    ((aInfo.attrib & FunctionAttribute.pure_)    ? ~0: ~FunctionAttribute.pure_) &
	    ((aInfo.attrib & FunctionAttribute.nogc)     ? ~0: ~FunctionAttribute.nogc) &
	    ((aInfo.attrib & (FunctionAttribute.safe | FunctionAttribute.trusted))
	    ? ~0
	    : ~(FunctionAttribute.safe | FunctionAttribute.trusted)));
	import std.string;
	static if (aInfo.params.length == bInfo.params.length)
	{
		enum bool isCastableDelegate = (aInfo.valiadic  == bInfo.valiadic)
		                            && isCovariantWith!(FunctionTypeOf!nonParamDgA, FunctionTypeOf!nonParamDgB)
		                            && isStcsConvertible!(aInfo.stcs, bInfo.stcs)
		                            && isParamsConvertible!(aInfo.params, bInfo.params);
	}
	else
	{
		enum bool isCastableDelegate = false;
	}
}
@system unittest
{
	class A{}
	class B: A{}
	class C: A{}
	static assert(isCastableDelegate!(void delegate(int), void delegate(int)));
	static assert(isCastableDelegate!(void delegate(int, int), void delegate(int, int)));
	static assert(isCastableDelegate!(void delegate(A, int), void delegate(A, int)));
	static assert(isCastableDelegate!(void delegate(B, int), void delegate(A, int)));
	static assert(isCastableDelegate!(void delegate(B, A), void delegate(A, A)));
	static assert(isCastableDelegate!(void delegate(int), void delegate(uint)));
	static assert(isCastableDelegate!(void delegate(byte), void delegate(int)));
	static assert(isCastableDelegate!(void delegate(byte) nothrow, void delegate(int) nothrow));
	static assert(isCastableDelegate!(void delegate(byte) @safe, void delegate(int) @system));
	static assert(isCastableDelegate!(void delegate(byte) @trusted, void delegate(int) @safe));
	static assert(isCastableDelegate!(void delegate(byte) @safe, void delegate(int) @trusted));
	//static assert(!isCastableDelegate!(void delegate(byte) @system, void delegate(int) @safe));
	static assert(!isCastableDelegate!(void delegate(B, A), void delegate(A, B)));
	static assert(!isCastableDelegate!(void delegate(C, C), void delegate(A, B)));
}

/*******************************************************************************
 * Generic Handler
 * 
 * 
 * $(__123 a, bbb) = xxx
 * 
 * Macros:
 *     bbb  = cccccc
 *     _123 = [$1 ::: $($2)]
 */
struct Handler(F)
	if (isCallable!F && (is(ReturnType!(F) == void) || is(ReturnType!(F) : bool)))
{
private:
	template _ExFuncInfo(Func)
	{
		alias FuncType = FunctionTypeOf!Func;
		alias RT       = ReturnType!Func;
		alias PT       = ParameterTypeTuple!Func;
		alias stcs     = ParameterStorageClassTuple!Func;
		alias valiadic = variadicFunctionStyle!Func;
		enum  attrib   = functionAttributes!Func;
		alias linkage  = functionLinkage!Func;
		alias abst     = isAbstractFunction!Func;
		alias virt     = isVirtualMethod!F;
	}
	alias _exFuncInfo = _ExFuncInfo!F;
	static private struct DummyData
	{
		template _EmitGeneratingPolicy()
		{
			template generateFunctionBody(unused...)
			{
				enum generateFunctionBody =
				q{
					static if (is(_exFuncInfo.RT: bool))
						return _exFuncInfo.RT.init;
				};
			}
		}
		mixin( MemberFunctionGeneratorEx!(_EmitGeneratingPolicy!())
				.generateFunction!("_exFuncInfo", _exFuncInfo, "emit")() );
	}
	template _EmitGeneratingPolicy()
	{
		template generateFunctionBody(unused...)
		{
			import std.conv;
			enum generateFunctionBody = "#line " ~ to!string(__LINE__+2) ~ 
			q{
				alias FnTy = SetFunctionAttributes!(typeof((*cast(Unique!ProcList*)&_procs)[].front),
				                                    _exFuncInfo.linkage, _exFuncInfo.attrib);
				static if (is(_exFuncInfo.RT: bool))
				{
					if ((*cast(Unique!ProcList*)&_procs).isEmpty())
						return _exFuncInfo.RT.init;
					_exFuncInfo.RT ret;
				}
				else
				{
					if ((*cast(Unique!ProcList*)&_procs).isEmpty())
						return;
				}
				static if (_exFuncInfo.attrib & FunctionAttribute.nothrow_)
				{
					try
					{
						foreach (FnTy proc; (*cast(Unique!ProcList*)&_procs)[].array())
						{
							static if (is(_exFuncInfo.RT: bool))
							{
								ret = proc(args);
								if (!ret)
									return ret;
							}
							else
							{
								proc(args);
							}
						}
					}
					catch (Throwable)
					{
					}
				}
				else
				{
					foreach (proc; (*cast(Unique!ProcList*)&_procs)[].array())
					{
						static if (is(_exFuncInfo.RT: bool))
						{
							ret = proc(args);
							if (!ret)
								return ret;
						}
						else
						{
							proc(args);
						}
					}
				}
				static if (is(_exFuncInfo.RT: bool))
					return ret;
			};
		}
	}
public:
	/***************************************************************************
	 * 
	 */
	version (D_Ddoc)
	{
		///
		RetType emit(Args args);
		/// ditto
		RetType emit(Args args) const;
		/// ditto
		RetType emit(Args args) shared const;
	}
	else
	{
		mixin( MemberFunctionGeneratorEx!(_EmitGeneratingPolicy!())
		       .generateFunction!("_exFuncInfo", _exFuncInfo, "emit")() );
	}
	/// ditto
	alias opCall   = emit;
	alias Proc     = F;
	alias Args     = _exFuncInfo.PT;
	alias RetType  =  _exFuncInfo.RT;
	alias ProcList = List!Proc;
	import voile.unique;
	private Unique!ProcList _procs;
	
	///
	static Proc toConnectable(Func)(Func fn)
		if (is(typeof( toDelegate(fn) ))
		 && isCastableDelegate!(Proc, typeof(toDelegate(fn))))
	{
		return cast(Proc)toDelegate(fn);
	}
	
	static if (Args.length > 0 && !hasUnsharedAliasing!Args)
	{
		static assert(Tid.sizeof == (void*).sizeof);
		private static void _TidCaller(Args args, Tid* tid)
		{
			(*cast(Tid*)&tid).send(args);
		}
		///
		static Proc toConnectable(Func)(Func tid)
			if (is(Func == Tid))
		{
			return cast(Proc)toDelegateEx(*cast(Tid**)&tid, &_TidCaller);
		}
		
		private static void _RangeOutputter(Range)(Args args, Range r)
		{
			if (!r.empty)
				.put(r, args);
		}
		///
		static Proc toConnectable(Range)(Range r)
			if (Args.length == 1
			&& isOutputRange!(Range, Args)
			&& !isCallable!Range
			&& (is(Range == class)
			 || is(Range == interface)
			 || isPointer!Range)
			&& is(typeof({ Range tmp; if (!tmp.empty) {} })))
		{
			return cast(Proc)toDelegateEx(r, &_RangeOutputter!Range);
		}
	}
	static if (Args.length == 0)
	{
		private static void _FiberCaller(Fiber fb) @trusted
		{
			fb.call();
		}
		///
		static Proc toConnectable(Func)(Func fib)
			if (is(Func: Fiber))
		{
			return cast(Proc)toDelegateEx(fib, &_FiberCaller);
		}
	}
	
	/***************************************************************************
	 * 
	 */
	alias HandlerProcId = ProcList.Iterator;
	
	/***************************************************************************
	 * Connect
	 * 
	 * Params:
	 *     fn = delegate, function, Tid, Object( has opCall ), Fiber,
	 *          OutputRange(class or interface or T*, and has empty method)
	 */
	HandlerProcId connect(Func)(Func fn)
		if (is(typeof( toConnectable(fn) )))
	{
		if (_procs.isEmpty())
			_procs = unique!ProcList;
		auto f = toConnectable(fn);
		_procs.stableInsertBack(f);
		auto r = _procs[];
		assert(r.back == f);
		return --r.end;
	}
	
	
	/***************************************************************************
	 * 一度だけ実行するハンドラを接続する
	 */
	HandlerProcId singleShotConnect(Func)(Func fn)
		if (is(typeof( toConnectable(fn) )))
	{
		static struct Data
		{
			void*         handler;
			Proc          proc;
			HandlerProcId id;
			auto ref call(Args args)
			{
				scope (exit)
				{
					(*cast(Handler*)&handler).disconnect(id);
					auto self = &this;
					object.destroy(self);
				}
				return proc(args);
			}
		}
		static auto ref _caller(Args args, Data* data)
		{
			return data.call(args);
		}
		if (_procs.isEmpty())
			_procs = unique!ProcList;
		auto proc = toConnectable(fn);
		auto d = new Data(*cast(void**)&_procs, toConnectable(fn), HandlerProcId.init);
		auto f = toConnectable(toDelegateEx(d, &_caller));
		_procs.stableInsertBack(cast(Proc)f);
		auto r = _procs[];
		assert(r.back == f);
		d.id = --r.end;
		return d.id;
	}
	
	/// ditto
	void opOpAssign(string op, Func)(Func dg) if (op == "~" && is(typeof(connect(dg))))
	{
		connect(dg);
	}
	
	
	/// ditto
	alias put = connect;
	
	
	/***************************************************************************
	 * 
	 */
	HandlerProcId connectedId(Func)(Func fn)
		if (is(typeof( toConnectable(fn) )))
	{
		if (_procs.isEmpty())
			return HandlerProcId.init;
		auto f = toConnectable(fn);
		for (auto r = _procs[]; !r.empty; r.popBack())
		{
			if (r.back == f)
				return --r.end;
		}
		
		return HandlerProcId.init;
	}
	
	
	/***************************************************************************
	 * Concut
	 * 
	 * Params:
	 *     procs = other Handler
	 */
	void opOpAssign(string op, ProcContainer)(auto ref ProcContainer procs)
		if (op == "~" && is(ForeachType!(typeof(ProcContainer.init[])): Proc))
	{
		if (_procs.isEmpty)
			_procs = unique!ProcList;
		foreach (p; procs[])
		{
			_procs.stableInsertBack(p);
		}
	}
	
	
	
	/***************************************************************************
	 * 
	 */
	auto opSlice()
	{
		if (_procs.isEmpty())
			_procs = unique!ProcList;
		return _procs[];
	}
	
	
	/***************************************************************************
	 * 
	 */
	bool opCast(T)() pure nothrow const
		if (is(T == bool))
	{
		return !_procs.isEmpty() && !_procs.empty();
	}
	
	
	/***************************************************************************
	 * 
	 */
	void disconnect(Func)(Func fn)
		if (is(typeof( toConnectable(fn) )))
	{
		disconnect(connectedId(fn));
	}
	
	/// ditto
	void disconnect(Func)(Func id)
		if (is(Func == HandlerProcId))
	{
		enforce(id);
		enforce(!_procs.isEmpty());
		_procs.stableLinearRemove(id);
	}
	
	/// ditto
	void disconnect(Func)(Func hnd)
		if (is(Func == Handler))
	{
		foreach (p; hnd._procs[])
		{
			_procs.stableLinearRemove(p);
		}
	}
	
	/// ditto
	alias remove = disconnect;
	
	/***************************************************************************
	 * 
	 */
	void insertAfter(Func)(ProcList.Range r, Func fn)
		if (is(typeof( toConnectable(fn) )))
	{
		auto id = connectedId(fn);
		if (id)
			disconnect(id);
		_procs.stableInsertAfter(r, toConnectable(fn));
	}
	
	/// ditto
	void insertAfter(Func)(HandlerProcId needleid, Func fn)
		if (is(typeof( toConnectable(fn) )))
	{
		auto id = connectedId(fn);
		if (id)
			disconnect(id);
		_procs.stableInsertAfter(needleid, toConnectable(fn));
	}
	
	/// ditto
	void insertAfter(Func)(Func needle, Func fn)
		if (is(typeof( toConnectable(fn) )))
	{
		auto id = connectedId(fn);
		if (id)
			disconnect(id);
		auto needleid = connectedId(needle);
		_procs.stableInsertAfter(needleid, toConnectable(fn));
	}
	
	/***************************************************************************
	 * 
	 */
	void insertBefore(Func)(ProcList.Range r, Func fn)
		if (is(typeof( toConnectable(fn) )))
	{
		auto id = connectedId(fn);
		if (id)
			disconnect(id);
		_procs.stableInsertBefore(r, toConnectable(fn));
	}
	
	/// ditto
	void insertBefore(Func)(HandlerProcId needleid, Func fn)
		if (is(typeof( toConnectable(fn) )))
	{
		auto id = connectedId(fn);
		if (id)
			disconnect(id);
		_procs.stableInsertBefore(needleid, toConnectable(fn));
	}
	
	/// ditto
	void insertBefore(Func)(Func needle, Func fn)
		if (is(typeof( toConnectable(fn) )))
	{
		auto id = connectedId(fn);
		if (id)
			disconnect(id);
		auto needleid = connectedId(needle);
		_procs.stableInsertBefore(needleid, toConnectable(fn));
	}
	
	/***************************************************************************
	 * 
	 */
	void clear() pure
	{
		if (_procs.isEmpty())
			return;
		_procs.release();
	}
}

debug (workaround)
@system unittest
{
	static string teststr;
	import std.conv: to;
	static void foo(int i)
	{
		teststr ~= "foo" ~ to!string(i);
	}
	Handler!(typeof(foo)) h;
	auto id1 = h.connect( &foo );
	h.connect( (int i){teststr ~= "dg" ~ to!string(i);} );
	auto id2 = h.connect( new class
	{
		void opCall(int i)
		{
			teststr ~= "opCall" ~ to!string(i);
		}
	} );
	teststr = "";
	h(1);
	assert(teststr == "foo1dg1opCall1", teststr);
	h.disconnect( &foo );
	teststr = "";
	h(2);
	assert(teststr == "dg2opCall2", teststr);
	assert(!h.connectedId( &foo ));
	
	h.disconnect(id2);
	h.connect(thisTid);
	h.clear();
	
	
	void bar()
	{
		while (1)
		{
			teststr ~= "bar";
			Fiber.yield();
		}
	}
	void bar2()
	{
		teststr ~= "bar2";
	}
	Handler!(typeof(bar)) h2;
	Fiber fib = new Fiber(&bar);
	h2.connect(fib);
	teststr = "";
	h2();
	assert(teststr == "bar");
	h2();
	assert(teststr == "barbar");
	
	Handler!(typeof(bar)) h3;
	h3.connect(&bar2);
	static assert(__traits(compiles, h2 ~= h3));
	h2 ~= h3;
	teststr = "";
	h2();
	assert(teststr == "barbar2");
}

@system unittest
{
	Handler!(void delegate() const) hndConst;
	Handler!(void delegate() immutable) hndImmutable;
	Handler!(void delegate() shared) hndShared;
	Handler!(void delegate() shared const) hndSharedConst;
	/* test for qualifier */
	{
		struct SQual
		{
			void fnConst() const {}
			void fnImmutable() immutable {}
			void fnShared() shared {}
			void fnSharedConst() shared const {}
		}
		SQual sq;
		auto dgConst       = toDelegate(&sq.fnConst);
		auto dgImmutable   = toDelegate(&(*cast(immutable   )&sq).fnImmutable);
		auto dgShared      = toDelegate(&(*cast(shared      )&sq).fnShared);
		auto dgSharedConst = toDelegate(&(*cast(shared const)&sq).fnSharedConst);
		static assert(is(FunctionTypeOf!dgConst       == const));
		static assert(is(FunctionTypeOf!dgImmutable   == immutable));
		static assert(is(FunctionTypeOf!dgShared      == shared));
		static assert(is(FunctionTypeOf!dgSharedConst == shared));
		static assert(is(FunctionTypeOf!dgSharedConst == const));
		hndConst.connect(&sq.fnConst);
		hndConst.disconnect(&sq.fnConst);
		hndImmutable.connect(     &(*cast(immutable   )&sq).fnImmutable);
		hndImmutable.disconnect(  &(*cast(immutable   )&sq).fnImmutable);
		hndShared.connect(        &(*cast(shared      )&sq).fnShared);
		hndShared.disconnect(     &(*cast(shared      )&sq).fnShared);
		hndSharedConst.connect(   &(*cast(shared      )&sq).fnSharedConst);
		hndSharedConst.disconnect(&(*cast(shared      )&sq).fnSharedConst);
	}
	{
		struct SConst       { void opCall() const {} }
		struct SImmutable   { void opCall() immutable {} }
		struct SShared      { void opCall() shared {} }
		struct SSharedConst { void opCall() shared const {} }
		auto idConst = hndConst.connect(SConst.init);
		hndConst.disconnect(idConst);
		auto idImmutable = hndImmutable.connect(cast(immutable)SImmutable.init);
		hndImmutable.disconnect(idImmutable);
		auto idShared = hndShared.connect(cast(shared)SShared.init);
		hndShared.disconnect(idShared);
		auto idSharedConst = hndSharedConst.connect(cast(shared)SSharedConst.init);
		hndSharedConst.disconnect(idSharedConst);
	}

}
